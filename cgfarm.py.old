import pyautogui
import time
import random
from PIL import ImageGrab
import threading
import keyboard
from ctypes_handler import CtypesMouseInjector
from datetime import datetime

def now():
    return datetime.now().strftime("[%H:%M:%S]")

class ClassI:
    def __init__(self):
        self.active = False
        self.shutdown = False
        self.last_move = time.time()
        self.move_interval = random.uniform(4, 50)
        self.duty_cycle = 10
        self.injector = CtypesMouseInjector()
        self.allow_movement = False


        keyboard.add_hotkey('-', self.decrease_duty_cycle)
        keyboard.add_hotkey('=', self.increase_duty_cycle)
        keyboard.add_hotkey('[', self.toggle_bot)
        threading.Thread(target=self.killswitch_listener, daemon=True).start()

        self.valid_auras = {
            "yellow": (231, 196, 60),
            "blue": (59, 229, 198)
        }
        self.valid_types = {
            "purple": (61, 16, 86),
            "grey1": (121, 140, 145),
            "grey2": (61, 75, 75)
        }
    def get_pixel(self, x, y):
        if not self.active:
            print(f"{now()} üõë Killswitch triggered before pixel grab‚Äîskipping ({x},{y})")
            return (0, 0, 0)
        try:
            img = ImageGrab.grab(bbox=(x, y, x+1, y+1))
            return img.getpixel((0, 0))
        except Exception as e:
            print(f"{now()} ‚ö†Ô∏è Pixel read failed at ({x},{y}): {e}")
            return (0, 0, 0)
    def color_match(self, c1, c2, tolerance=20):
        return all(abs(a - b) <= tolerance for a, b in zip(c1, c2))
    def click(self, x, y):
        jiggle_radius = 3
        for dx, dy in [(-jiggle_radius, 0), (jiggle_radius, 0), (0, -jiggle_radius), (0, jiggle_radius)]:
            self.injector.move(x + dx, y + dy)
            time.sleep(0.01)
        self.injector.move(x, y)
        time.sleep(0.05)
        self.injector.click(x, y)
        time.sleep(0.05)
    def increase_duty_cycle(self):
        self.duty_cycle = min(60, self.duty_cycle + 1)
        print(f"{now()}üî∫ Duty cycle: {self.duty_cycle}s")
    def decrease_duty_cycle(self):
        self.duty_cycle = max(1, self.duty_cycle - 1)
        print(f"{now()}üîª Duty cycle: {self.duty_cycle}s")
    def get_chest_ui_region(self):
        return [(x, y) for x in range(796, 796 + 95) for y in range(914, 914 + 35)]
    def red_saturation(self, region):
        red_pixels = 0
        total_pixels = 0
        for x, y in region:
            if not self.active:
                print(f"{now()} üõë Killswitch triggered during red saturation scan‚Äîexiting")
                return 0
            pixel = self.get_pixel(x, y)
            if pixel[0] > 150 and pixel[0] > pixel[1] + 50 and pixel[0] > pixel[2] + 50:
                red_pixels += 1
            total_pixels += 1
        return red_pixels / total_pixels if total_pixels else 0
    def wait_for_red_drop(self, threshold=0.95, timeout=15):
        region = self.get_chest_ui_region()
        start_time = time.time()
        while time.time() - start_time < timeout:
            if not self.active:
                print(f"{now()} üõë Killswitch triggered during red drop wait‚Äîexiting")
                return False
            saturation = self.red_saturation(region)
            print(f"{now()} üî¥ Red saturation: {saturation:.3f}")
            if saturation < threshold:
                print(f"{now()} üì¥ Chest UI cleared (red dropped)")
                self.allow_movement
                time.sleep(random.uniform(1.5, 2.5))
                return True
            if self.discard_button_darkened():
                print(f"{now()} üåí Discard button darkened‚Äîassuming chest cycle complete")
                self.allow_movement
                time.sleep(random.uniform(1.5, 2.5))
                return True
            time.sleep(0.2)
        print(f"{now()} ‚è±Ô∏è Red saturation timeout")
        return False
    def discard_button_present(self):
        region = [(x, y) for x in range(800, 800 + 90) for y in range(915, 915 + 30)]
        target_colors = [(255, 0, 7), (179, 0, 5)]
        for x, y in region:
            if not self.active:
                print(f"{now()} üõë Killswitch triggered during discard scan‚Äîexiting")
                return False
            pixel = self.get_pixel(x, y)
            for target in target_colors:
                if self.color_match(pixel, target, tolerance=30):
                    print(f"{now()} üéØ Discard button matched tone: {target}")
                    return True
        return False
    def discard_button_darkened(self):
        pixel = self.get_pixel(845, 930)  # Sample center of discard button
        # If red channel is low and green/blue rise, it's darkened
        return pixel[0] < 100 and pixel[1] > 50 and pixel[2] > 50
    def wait_for_discard_absence(self, timeout=15):
        start_time = time.time()
        while self.discard_button_present():
            if time.time() - start_time > timeout:
                print(f"{now()}‚è±Ô∏è Discard button still present after timeout")
                return False
            time.sleep(0.1)
        print(f"{now()}üì¥ Discard button gone")
        time.sleep(random.uniform(4, 5))
        return True
    def walk_forward(self, duration=10):
        print(f"{now()}üö∂ Walking forward for {duration}s")
        self.hold_key('w', duration)
    def hold_key(self, key, duration):
        pyautogui.keyDown(key)
        time.sleep(duration)
        pyautogui.keyUp(key)
    def detect_death(self):
        return self.color_match(self.get_pixel(859, 679), (195, 232, 255))
    def handle_death(self):
        self.click(859, 679)
        print(f"{now()}üíÄ Respawned")
        self.allow_movement = False
        time.sleep(1)
    def get_aura_and_type(self):
        aura = self.get_pixel(1015, 679)
        chest_type = self.get_pixel(960, 500)
        return aura, chest_type
    def is_valid_aura(self, c):
        return any(self.color_match(c, val) for val in self.valid_auras.values())
    def is_valid_type(self, c):
        return any(self.color_match(c, val) for val in self.valid_types.values())
    def is_wood_chest(self):
        region = [(x, y) for x in range(990, 1000) for y in range(840, 850)]
        match_count = 0
        volatile_count = 0
        ref_pixel = self.get_pixel(995, 845)
        for x, y in region:
            pixel = self.get_pixel(x, y)
            if self.color_match(pixel, (220, 198, 165), tolerance=30):
                match_count += 1
            if not self.color_match(pixel, ref_pixel, tolerance=10):
                volatile_count += 1
        return match_count > 50 and volatile_count < 20
    def handle_chest(self):
        chest_count = 0
        start_time = time.time()
        while self.discard_button_present():
            if not self.active:
                print(f"{now()}üõë Killswitch triggered during chest cycle‚Äîexiting")
                return
            aura, chest_type = self.get_aura_and_type()
            if self.is_valid_aura(aura) or self.is_valid_type(chest_type):
                self.click(950, 800)
                print(f"{now()}üì¶ Chest #{chest_count + 1} opened")
                # Chest readiness check
                red_ready = self.red_saturation(self.get_chest_ui_region()) > 0.8
                button_ready = not self.discard_button_darkened()
                pixel = self.get_pixel(1000, 850)
                if red_ready and button_ready:
                    if self.color_match(pixel, (0, 255, 0), tolerance=40):
                        self.click(1000, 850)
                        print(f"{now()}‚úÖ Green pixel detected ‚Üí clicked 1000,850")
                    else:
                        self.click(1000, 750)
                        print(f"{now()}‚ùé Not green ‚Üí clicked 1000,750")
                else:
                    print(f"{now()}‚ö†Ô∏è Chest UI not ready or button dark‚Äîskipping click")
                self.wait_for_red_drop(threshold=0.95, timeout=15)
            else:
                self.click(950, 950)
                print(f"{now()}üóëÔ∏è Chest #{chest_count + 1} discarded")
            chest_count += 1
            time.sleep(random.uniform(0.5, 1.0))
        print(f"{now()}‚úÖ Chest cycle complete after {chest_count} chests")
        self.allow_movement = True
    def check_zone(self):
        try:
            zone_color = self.get_pixel(140, 115)
        except Exception as e:
            print(f"{now()}‚ö†Ô∏è Zone pixel read failed: {e}")
            return False
        if self.color_match(zone_color, (78, 50, 43)):  # 4E322B ‚Äî spawn zone
            print(f"{now()}‚Ü™Ô∏è Rejoining play area")
            self.hold_key('w', 10)
            return False  # Still in spawn, not ready
        elif self.color_match(zone_color, (220, 198, 165)):  # DCC6A5 ‚Äî active zone
            return True
        else:
            print(f"{now()}‚ùì Unknown zone color: {zone_color}")
            return False

    def killswitch_listener(self):
        self.shutdown = True
        while not self.shutdown:
            if keyboard.is_pressed('j') and keyboard.is_pressed('k') and keyboard.is_pressed('l'):
                self.shutdown = True
                self.active = False
                print(f"{now()}üõë Killswitch activated")
            time.sleep(0.1)
    def toggle_bot(self):
        if not self.shutdown:
            self.active = not self.active
            print(f"{now()}üîÅ Bot {'ENABLED' if self.active else 'DISABLED'}")
    def run(self):
        print(f"{now()}üîÅ Loop started")
        death_check_interval = 2.5
        last_death_check = time.time()
        print(f"{now()} üéÆ ClassI initialized. Press [ to toggle. J+K+L to kill.")
        try:
            while not self.shutdown:
                if not self.active:
                    time.sleep(0.25)
                    continue
                print(f"{now()} üéÆ CGfarm successfully loaded. (c) Copilot & Pank.")
                # Death check
                if time.time() - last_death_check >= death_check_interval:
                    last_death_check = time.time()
                    if self.detect_death():
                        self.handle_death()
                        self.handle_chest()
                        continue  # Skip movement until chest is handled
                # Zone check
                if not self.check_zone():
                    time.sleep(0.5)
                    continue
                # Movement logic
                if self.allow_movement and time.time() - self.last_move > self.move_interval:
                    print(f"{now()} üö∂ Movement triggered")
                    self.random_movement()
                    self.last_move = time.time()
                    self.move_interval = random.uniform(4, 50)
                time.sleep(0.25)
        except Exception as e:
            print(f"{now()} ‚ùå Fatal error: {e}")

# === Launch ===
if __name__ == "__main__":
    bot = ClassI()
    bot.run()